/*
 * Copyright (C) 2023 thevalidator
 */
package ru.thevalidator.tictactoe.gui;

import java.awt.Color;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.imageio.ImageIO;
import static ru.thevalidator.tictactoe.gui.Settings.BOX_SIZE;
import static ru.thevalidator.tictactoe.gui.Settings.MAIN_WINDOW_WIDTH;
import static ru.thevalidator.tictactoe.gui.Settings.MARGIN;
import ru.thevalidator.tictactoe.model.Board;
import ru.thevalidator.tictactoe.model.Role;
import ru.thevalidator.tictactoe.model.StatusData;

/**
 *
 * @author thevalidator
 */
public class GameBoardPanel extends javax.swing.JPanel implements MouseListener {

    private StatusData status;
    private final Board board;
    private boolean isCrosses;
    private boolean isOver;
    private int actionsNumber;
    private Image cross;
    private Image circle;
    private Image crossWin;
    private Image circleWin;

    /**
     * Creates new form GameBoardPanel
     */
    public GameBoardPanel() {
        loadImages();
        //resetActions();
        this.board = new Board();
        initComponents();
    }

    public void setStatus(StatusData status) {
        this.status = status;
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        setBackground(new java.awt.Color(0, 153, 204));

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 400, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 300, Short.MAX_VALUE)
        );
    }// </editor-fold>//GEN-END:initComponents

    private int getRowNumber(int y) {
        return y / (getSize().height / board.getVerticalSize());
    }

    private int getColumnNumber(int x) {
        return x / ((getSize().width / board.getHorisontalSize()));
    }

    @Override
    public void mouseClicked(MouseEvent e) {
        int xClickPos = e.getX();
        int yClickPos = e.getY();
        if (!isOver && gamingAreaClicked(xClickPos, yClickPos)) {
            int x = getColumnNumber(xClickPos);
            int y = getRowNumber(yClickPos);
            if (board.getboxValue(x, y) == 0) {
                Role role = isCrosses ? Role.CROSS : Role.NOUGHT;
                board.setBoxValue(x, y, role);
                actionsNumber++;
            }
            isCrosses = !isCrosses;
            if (isFinished()) {
                isOver = true;
            } else {
                status.setStatus(isCrosses ? "CROSSES TURN" : "NOUGHTS TURN", Color.LIGHT_GRAY);
            }
            repaint();

            //System.out.printf("x=%d y=%d\n", xClickPos, yClickPos);
            //System.out.printf("POINT[x=%d:y=%d] value=%d  -  Step: %d\n", x, y, board.getboxValue(x, y), actionsNumber);
        }

    }

    private boolean gamingAreaClicked(int x, int y) {
        // TODO: fix gaming area for grid lines (exclude lines area)
        boolean a = x >= MARGIN && x <= (MAIN_WINDOW_WIDTH - MARGIN);
        boolean b = y >= MARGIN && y <= (MAIN_WINDOW_WIDTH - MARGIN);
        return a && b;
    }

    @Override
    public void mousePressed(MouseEvent e) {
        //throw new UnsupportedOperationException("Not supported yet.");
    }

    @Override
    public void mouseReleased(MouseEvent e) {
        //throw new UnsupportedOperationException("Not supported yet.");
    }

    @Override
    public void mouseEntered(MouseEvent e) {
        //throw new UnsupportedOperationException("Not supported yet.");
    }

    @Override
    public void mouseExited(MouseEvent e) {
        //throw new UnsupportedOperationException("Not supported yet.");
    }

    public void drawGrid(Graphics panel) {
        panel.setColor(Color.DARK_GRAY);
        for (int i = 1; i < 3; i++) {
            panel.fillRect((MAIN_WINDOW_WIDTH - (MARGIN * 2)) / 3 * i, MARGIN, MARGIN, MAIN_WINDOW_WIDTH - MARGIN * 4);
            panel.fillRect(MARGIN, (MAIN_WINDOW_WIDTH - (MARGIN * 2)) / 3 * i, MAIN_WINDOW_WIDTH - MARGIN * 4, MARGIN);
        }
    }

    private void drawFigures(Graphics g) {
        for (int y = 0; y < board.getVerticalSize(); y++) {
            for (int x = 0; x < board.getHorisontalSize(); x++) {
                // TODO: refactor selection figure to draw logic
                int value = board.getboxValue(x, y);
                if (value == Role.CROSS_WIN.getValue()) {
                    drawFigure(g, crossWin, x, y);
                } else if (value == Role.NOUGHT_WIN.getValue()) {
                    drawFigure(g, circleWin, x, y);
                } else if (value == Role.CROSS.getValue()) {
                    drawFigure(g, cross, x, y);
                } else if (value == Role.NOUGHT.getValue()) {
                    drawFigure(g, circle, x, y);
                }
            }
        }
    }

    private void drawFigure(Graphics g, Image figure, int x, int y) {
        int imgSize = figure.getWidth(null);
        int start = MARGIN + BOX_SIZE / 2 - imgSize / 2;
        int offset = BOX_SIZE + MARGIN / 2;

        //int crossLineStart = BOX_SIZE / 2 + MARGIN;
        //int crossLineOffset = BOX_SIZE + MARGIN / 2;
        g.drawImage(figure, start + offset * x, start + offset * y, null);
    }

    @Override
    protected void paintComponent(Graphics g) {
        super.paintComponent(g);
        drawGrid(g);
        drawFigures(g);
    }

    public void clearBoard() {
        clearValues();
        repaint();
    }

    private void clearValues() {
        status.setStatus(isCrosses ? "CROSSES TURN" : "NOUGHTS TURN", Color.LIGHT_GRAY);
        board.resetValues();
        isOver = false;
        actionsNumber = 0;
        //resetActions();
    }

    private boolean isFinished() {

        boolean isFinished;
        isFinished = checkHorisontals();
        if (!isFinished) {
            isFinished = checkVerticals();
        }
        if (!isFinished) {
            isFinished = checkLeftDiagonal();
        }
        if (!isFinished) {
            isFinished = checkRightDiagonal();
        }
        if (!isFinished && actionsNumber == 9) {
            isFinished = true;
            status.setStatus("TIE", Color.MAGENTA);
        }

        //System.out.println(">>> IS FINISHED: " + isFinished);
        return isFinished;
    }

    private boolean checkRightDiagonal() {
        List<Integer> line = new ArrayList<>();
        int sum = 0;
        int x = board.getVerticalSize() - 1;
        int y = 0;
        for (; x >= 0;) {
            sum += board.getboxValue(x, y);
            line.add(x);
            line.add(y);
            x--;
            y++;
        }
        if (threeInARow(sum)) {
            handleWin(sum, line);
            return true;
        }
        return false;
    }

    private boolean checkLeftDiagonal() {
        List<Integer> line = new ArrayList<>();
        int sum = 0;
        for (int i = 0; i < board.getVerticalSize(); i++) {
            sum += board.getboxValue(i, i);
            line.add(i);
            line.add(i);
        }
        if (threeInARow(sum)) {
            handleWin(sum, line);
            return true;
        }
        return false;
    }

    private boolean checkVerticals() {
        List<Integer> line = new ArrayList<>();
        for (int x = 0; x < board.getHorisontalSize(); x++) {
            int sum = 0;
            for (int y = 0; y < board.getVerticalSize(); y++) {
                sum += board.getboxValue(x, y);
                line.add(x);
                line.add(y);
            }
            if (threeInARow(sum)) {
                handleWin(sum, line);
                return true;
            }
            line.clear();
        }
        return false;
    }

    private boolean checkHorisontals() {
        List<Integer> line = new ArrayList<>();
        for (int y = 0; y < board.getVerticalSize(); y++) {
            int sum = 0;
            for (int x = 0; x < board.getHorisontalSize(); x++) {
                sum += board.getboxValue(x, y);
                line.add(x);
                line.add(y);
            }
            if (threeInARow(sum)) {
                handleWin(sum, line);
                return true;
            }
            line.clear();
        }
        return false;
    }

    private static boolean threeInARow(int sum) {
        return Math.abs(sum) == 3;
    }

    private void handleWin(int sum, List<Integer> line) {
        Role winner = getWinner(sum);
        updateWinStats(winner);
        markWinLine(winner, line);
        status.setStatus(winner + " WIN", Color.GREEN);
    }

    private Role getWinner(int sum) {
        if (sum > 0) {
            return Role.CROSS;
        } else {
            return Role.NOUGHT;
        }
    }

    private void updateWinStats(Role role) {
        status.incrementWinValue(role);
    }

    private void markWinLine(Role winner, List<Integer> line) {
        if (winner.equals(Role.CROSS)) {
            winner = Role.CROSS_WIN;
        } else {
            winner = Role.NOUGHT_WIN;
        }
        for (int i = 0; i < line.size(); i += 2) {
            board.setBoxValue(line.get(i), line.get(i + 1), winner);
        }
    }

//    private void resetActions() {
//        actionsNumber = 0;
//    }

    private void loadImages() {
        try {
            cross = ImageIO.read(getClass().getClassLoader().getResource("icons/cross.png"));
            circle = ImageIO.read(getClass().getClassLoader().getResource("icons/circle.png"));
            crossWin = ImageIO.read(getClass().getClassLoader().getResource("icons/cross_WIN.png"));
            circleWin = ImageIO.read(getClass().getClassLoader().getResource("icons/circle_WIN.png"));
        } catch (IOException ex) {
            Logger.getLogger(GameBoardPanel.class.getName()).log(Level.SEVERE, null, ex);
        }
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    // End of variables declaration//GEN-END:variables
}

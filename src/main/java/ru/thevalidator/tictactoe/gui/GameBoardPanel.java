/*
 * Copyright (C) 2023 thevalidator
 */
package ru.thevalidator.tictactoe.gui;

import java.awt.Color;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.io.IOException;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.imageio.ImageIO;
import static ru.thevalidator.tictactoe.gui.Settings.BOX_SIZE;
import static ru.thevalidator.tictactoe.gui.Settings.MAIN_WINDOW_WIDTH;
import static ru.thevalidator.tictactoe.gui.Settings.MARGIN;
import ru.thevalidator.tictactoe.model.Board;
import ru.thevalidator.tictactoe.model.Role;

/**
 *
 * @author thevalidator
 */
public class GameBoardPanel extends javax.swing.JPanel implements MouseListener {

    private final Board board;
    private boolean isPlayer;
    private int actionsNumber;

    /**
     * Creates new form GameBoardPanel
     */
    public GameBoardPanel() {
        resetActions();
        this.board = new Board();
        initComponents();
        //addMouseListener(this);
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        setBackground(new java.awt.Color(0, 153, 204));

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 400, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 300, Short.MAX_VALUE)
        );
    }// </editor-fold>//GEN-END:initComponents

    private int getRowNumber(int y) {
        return y / (getSize().height / board.getVerticalSize());
    }

    private int getColumnNumber(int x) {
        return x / ((getSize().width / board.getHorisontalSize()));
    }

    @Override
    public void mouseClicked(MouseEvent e) {
        int xClickPos = e.getX();
        int yClickPos = e.getY();
        System.out.printf("x=%d y=%d\n", xClickPos, yClickPos);

        if (gamingAreaClicked(xClickPos, yClickPos)) {
            int x = getColumnNumber(xClickPos);
            int y = getRowNumber(yClickPos);
            if (board.getboxValue(x, y) == 0) {
                isPlayer = !isPlayer;
                Role role = isPlayer ? Role.CROSS : Role.NOUGHT;
                board.setBoxValue(x, y, role);
                actionsNumber++;
            }
            if (isFinished()) {
                // TO DO: crossing line if win
            }
            repaint();
            System.out.printf("POINT[x=%d:y=%d] value=%d  -  Step: %d\n", x, y, board.getboxValue(x, y), actionsNumber);
        }

    }

    private boolean gamingAreaClicked(int x, int y) {
        // TODO: fix gaming area for grid lines (exclude lines area)
        boolean a = x >= MARGIN && x <= (MAIN_WINDOW_WIDTH - MARGIN);
        boolean b = y >= MARGIN && y <= (MAIN_WINDOW_WIDTH - MARGIN);
        return a && b;
    }

    @Override
    public void mousePressed(MouseEvent e) {
        //throw new UnsupportedOperationException("Not supported yet.");
    }

    @Override
    public void mouseReleased(MouseEvent e) {
        //throw new UnsupportedOperationException("Not supported yet.");
    }

    @Override
    public void mouseEntered(MouseEvent e) {
        //throw new UnsupportedOperationException("Not supported yet.");
    }

    @Override
    public void mouseExited(MouseEvent e) {
        //throw new UnsupportedOperationException("Not supported yet.");
    }

    public void drawGrid(Graphics panel) {
        panel.setColor(Color.DARK_GRAY);
        for (int i = 1; i < 3; i++) {
            panel.fillRect((MAIN_WINDOW_WIDTH - (MARGIN * 2)) / 3 * i, MARGIN, MARGIN, MAIN_WINDOW_WIDTH - MARGIN * 4);
            panel.fillRect(MARGIN, (MAIN_WINDOW_WIDTH - (MARGIN * 2)) / 3 * i, MAIN_WINDOW_WIDTH - MARGIN * 4, MARGIN);
        }
    }

    private void drawFigures(Graphics g) {
        try {
            Image cross = ImageIO.read(getClass().getClassLoader().getResource("icons/cross.png"));
            Image circle = ImageIO.read(getClass().getClassLoader().getResource("icons/circle.png"));
            Image crossWin = ImageIO.read(getClass().getClassLoader().getResource("icons/cross_WIN.png"));
            Image circleWin = ImageIO.read(getClass().getClassLoader().getResource("icons/circle_WIN.png"));

            for (int y = 0; y < board.getVerticalSize(); y++) {
                for (int x = 0; x < board.getHorisontalSize(); x++) {
                    // TODO: refactor selection figure to draw logic
                    int value = board.getboxValue(x, y);
                    if (value == Role.CROSS_WIN.getValue()) {
                        drawFigure(g, crossWin, x, y);
                    } else if (value == Role.NOUGHT_WIN.getValue()) {
                        drawFigure(g, circleWin, x, y);
                    } else if (value == Role.CROSS.getValue()) {
                        drawFigure(g, cross, x, y);
                    } else if (value == Role.NOUGHT.getValue()) {
                        drawFigure(g, circle, x, y);
                    }
                }
            }

        } catch (IOException ex) {
            Logger.getLogger(MainWindow.class.getName()).log(Level.SEVERE, null, ex);
        }
    }

    private void drawFigure(Graphics g, Image figure, int x, int y) {
        int imgSize = figure.getWidth(null);
        int start = MARGIN + BOX_SIZE / 2 - imgSize / 2;
        int offset = BOX_SIZE + MARGIN / 2;

        int crossLineStart = BOX_SIZE / 2 + MARGIN;
        int crossLineOffset = BOX_SIZE + MARGIN / 2;
        g.drawImage(figure, start + offset * x, start + offset * y, null);
    }

    @Override
    protected void paintComponent(Graphics g) {
        super.paintComponent(g);
        drawGrid(g);
        drawFigures(g);
    }
    
    public void clearBoard() {
        clearValues();
        repaint();
    }
    
    private void clearValues() {
        board.resetValues();
        resetActions();
    }

    private boolean isFinished() {
        boolean isFinished = false;

        for (int y = 0; y < board.getVerticalSize(); y++) {
            int sum = 0;
            for (int x = 0; x < board.getHorisontalSize(); x++) {
                sum += board.getboxValue(x, y);
            }
            if (Math.abs(sum) == 3) {
                isFinished = true;
                break;
            }

        }

        for (int x = 0; x < board.getHorisontalSize(); x++) {
            int sum = 0;
            for (int y = 0; y < board.getVerticalSize(); y++) {
                sum += board.getboxValue(x, y);
            }
            if (Math.abs(sum) == 3) {
                isFinished = true;
                break;
            }

        }

        int sum = 0;
        for (int i = 0; i < board.getVerticalSize(); i++) {
            sum += board.getboxValue(i, i);
        }
        if (Math.abs(sum) == 3) {
            isFinished = true;
        }
        
        int sum2 = 0;
        int x = board.getVerticalSize() - 1;
        int y = 0;
        for (; x >= 0;) {
            sum2 += board.getboxValue(x, y);
            x--;
            y++;
        }
        if (Math.abs(sum2) == 3) {
            isFinished = true;
        }
        
        if (!isFinished && actionsNumber == 9) {
            isFinished = true;
        }

        System.out.println(">>> IS FINISHED: " + isFinished);
        return isFinished;
    }
    
    private void resetActions() {
        actionsNumber = 0;
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    // End of variables declaration//GEN-END:variables
}
